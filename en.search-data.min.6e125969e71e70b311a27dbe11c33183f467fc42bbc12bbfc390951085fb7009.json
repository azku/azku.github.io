[{"id":0,"href":"/docs/grafana/","title":"Grafana","section":"Docs","content":"BI tresna barruan denboran zehar adierazi behar diren grafikoentzako, Grafana software libre munduan aurkitu daitekeen aukera bat da.\nGrafanaren gaitasunak erakusteko, datuak behar dira eta horretarako erabiliko dugu Prometheus node_explorerrekin. Bi hauek zerbitzari batean egongo dira instalatuta.\nPrometheus instalazioa # Prometheus Ansible birtartez instalatzeko ondorengo esteka erabili dezakegu.\nGrafana instalazioa # Grafana Ansible bitartez instalatzeko ondorengo esteka erabili daiteke.\nJarduera # Behin Grafana eta Prometheus sare berean instalatuta izanik node_exporterreko makinaren egoera azaleraraziko duten grafikoak egitea proposatzen da. Grafanaren gaitasun desberdinak probatzea da helburua.\n"},{"id":1,"href":"/docs/metabase/","title":"Metabase","section":"Docs","content":"BI tresna barruan grafiko orokorrak modu azkar eta malgu batean sortzeko Metabase da aukera bat.\nMetabaseren gaitasunak erakusteko, Eustaten aurkitu ditzakegun datuak erabiliko ditugu.\nMetabase instalazioa # Docker # Metabase konfiguratuta dagoen Docker kontainer bat erabiliko dugu. Lehenengo pausoa beraz, Docker instalatzea da. Horretarako ondorengo estekan prestatuta dagoen Ansible playbooka erabiliko dugu.\nMetabase # Metabaseko kontainerra prestatzeko, dagokion postgresql kontainerrarekin batera, ondorengo estekan prestatuta dagoen Ansible playbooka erabiliko dugu.\nJarduera # Behin Metabase martxan dagoela, hasieran aipatutako Eustateko datuak inportatu eta euskadin erditzeek izan duten garaopena aztertuko dugu grafika desberdinak sortuaz. Metabaseren gaitasun desberdinak probatzea da helburua.\n"},{"id":2,"href":"/docs/pasahitzak/","title":"Pasahitz kudeatzailea","section":"Docs","content":"Konputagailuen munduan autentikazioa eta autorizazioaren kudeaketa landu beharreko gaia da erabiltzaile guztiontzat. Bide publikoetatik gidatzean ditzakegun seinaleak identifikatu behar diren bezala, inguru digitaletan aritzerakoan gutxieneko batzu egon beharko litzateela pentsatzen duen horietakoa naiz.\nPasahitza - zaharra baina azkarra # Gure pasahitz maiteak ahanzturara bidaliko omen zituen mila eta bat alternatiba ikusi ditut urteetan. Errealitatea da, gaur egun, 2025ean behitzat, pasahitzak direla webgune gehienetara sartzeko, gehiengoak erabiltzen duen autetikazio tresna.\nEz errepikatu mesedez # Gero eta gehiago behartzen gaituzte erabiltzaileak pasahitzak konplexuak sortzera. Horrela, alfabetuko karaktereez aparte, zenbakiak eta karaktere ez alfanumerikoak sartzera behartzen gaituzte. Pasahitz seguruak sortzea ideia hona da. Pashitz hauek gogoratzea zaila egiten zaigu ordea, eta honek pasahitzen berrerabilpenera eraman gaitzake. Alegia, pasahitz bera erabiltzera webgune ezberdinetan edo helburu desberdinetarako. Hau oso praktika kaxkarra da eta ekidin behar dugu.\nPasahitz Kudeatzaileak # Beraz, gizakiontzak gogoratzeko pasahitz zailak eta asko sortu behar baditugu, nola gogoratuko ditugu? Erantzuna: ez ditugu gogoratu behar, pasahitz kudeatzaile bat erabiltzea aitortzen da gaur egun praktika egokitzat.\nZein ordea? # Hemen gusto eta kolore asko ditugu. Ni ez naiz produktu desberdinak baloratzera sartuko. Denean daude abantailak eta desabantailak, baita nik proposatuko dudanean: Unixetik datorre pass programa.\nZer da pass? # Enkriptatzeko gpg programa erabiltzen duen kudeatzaile sinple bat da. Autentikazio helburu bakoitza fitxategi desberdin batean gordetze du eta denak enkriptatu egiten ditu. Oinarrian GPG enkripzioa eta fitxategi sistema besterik ez ditu erabiltzen.\nLinux # GNU/Linux sistema eragileetan, ohikoa da sistemako paketeekin batera instalatzeko aukera izatea. Archlinuxen kasu partikularrean adibidez pacman -S pass bidez instalatzen da. GPG instalatuta izateaz gain, gako publiko/pribatu pare bat sortu beharko dugu: gpg --expert --full-gen-key erabili daiteke horretarako. Pass erabiltzen hasteko prest geundeke. Lehenengo pausoa gordailua hasieratzea litzateke. Edozein kasutan, pass-en dokumentazioan oso ondo azaltzen da bere funtzionamendua.\nEmacs # Emacsek pass Password-Store modua dauka. Honek pass programa erabiltzen du eta bertako pasahitzak emacs bidez atzitzeko aukera eskaintzen du. Emcaseko Melpa pakeeten listan pass (Major mode for password-store.el) bezala agertzen da.\nWindowsen emandako pausoak # Windowsen ez dut lortu oraindik emacs bitartez erabiltzerik. Ala era badago pass-winmenu izeneko programa bat eta honek Windoseko menu bezala pasahitzak atzitzeko aukera ematen du.\nHorretarako lehenik git instalatu eta errepositorioa inportatu beharko dugu. Nire kasuan, pass gordailua beste konputagailu batean sort ua nuen eta horregaitik da inportazioa lehenengo pausoa.\nOndoren gpg4win instalatu eta gako pribatua inportatu. Beste konputagailuan gakoa exportatu behar izan dugu lehenik.\npass-winmenu jeitsi deskromprimitu eta dokumentuen direktoriora eraman. Guk gpg4win instalatu dugunez, pass-winmenu.yaml fitxategian ondorengo aldaketa egin behar da: gpg-path: 'gpg'\n"},{"id":3,"href":"/docs/txirrindularitza/","title":"Txirrindularitza Proiektua","section":"Docs","content":" Informazioa prozesatzea # Ubuntu zerbitzari instalazio batetik habiatuta, YOLOV8 modeloa erabiliz argazkien predikzioak egiteko ondorengo pausoak jarraitu behar dira. Lehenengo eta behin, beharrezkoak diren pakete pare bat instalatu eta python ingurune bat sortu beharko dugu. Ingurunea sortzearen arrazoia, pip komandoaren erabilera da. Instalazio berrietan pythonen paketeak instalatzeko ingurune kontrolatuak sortzeko gomendia bultzatzen da:\n1sudo apt-get install -y libgl1-mesa-dev 2sudo apt-get install -y libglib2.0-0 3sudo apt install python3.12-venv 4python3 -m venv .venv/ 5 6.venv/bin/pip install ultralytics 7.venv/bin/pip install imutils Ondorengo python kodeak, direktorio batean dauden argazkiak aztertu eta obketu detekzioa aplikatuko die, CSV batean emaitzak hutsiz. Kode guztia github.com/azku/txirrindularitza URLan aurkitu daiteke.\nDokumentuak Igotzea # Probatzen gabiltzan gailuek, wifi sarera konektatzeko dauketen zailtasuna dela eta, hasierako bertsio baterako datuak webgune baten bitartez igotzea proposatu dugu. Horretarako OVHCloud plataforman zerbitzari bat jarri dugu Ubuntu 24.04 Sistema Eragile batekin instalaturik.\nBertan Docker kontainerrak erabilita, Wordpress webgune bat ezarriko dugu eta hau editatu bertan fitxategiak igo ahal izateko.\nWebgunea http://fptxurdinaga.in:8080/ helbidean jarri da eskuragarri.\nWorpressen Contact Form 7, Drag and Drop Multiple File Upload - Contact Form 7 eta Flamingo pluginak instalatu dira fitxategiak zerbitzarira web bitartez igotzeko. Lehenengo 2 pluginak Wordpressen inprimakiak sortzeko eta fitxategi anitz batera igotzeko aukera izateko erabili dira. Flamingo inprimaki bidalketa guztiak gordeta izateko erabili da.\nWorpressetik (Docker) datuak ateratzea # Datuak bi fasetan aterako dira. Alde batetik, iruadiak eskuz aterako dira docker komandoak erabilita.\n1docker cp wordpress:/var/www/html/wp-content/uploads/wp_dndcf7_uploads/wpcf7-files/*.png data/ Metadatuak, Flamengok Mysql datu-basean gordetzen ditu, eta hauek argazki fisikoekin lotzeko, python funtzio bat sortu da. Aurrez aipatu den bezala, kode guztia github.com/azku/txirrindularitza URLan aurkitu daiteke. Fitxategi hau argazkien_metadatoak_ekarri.py deitzen da.\nDatuei begirada # Prozesamenduak emaitza bezala eskaintzen duen fitxategia estatistikoki interpretatzeko, Metabase sistema bat instalatu da. Sistema horretara CSV fitxategia inportatu eta aztertu daiteke.\nMetabase martxan jartzeko Docker Compose erabili dugu. Hona hemen fitxategia:\n1services: 2 metabase: 3 image: metabase/metabase:latest 4 container_name: metabase 5 hostname: metabase 6 volumes: 7 - /dev/urandom:/dev/random:ro 8 ports: 9 - 3000:3000 10 environment: 11 MB_DB_TYPE: postgres 12 MB_DB_DBNAME: metabaseappdb 13 MB_DB_PORT: 5432 14 MB_DB_USER: metabase 15 MB_DB_PASS: mysecretpassword 16 MB_DB_HOST: postgres 17 networks: 18 - metanet1 19 healthcheck: 20 test: curl --fail -I http://localhost:3000/api/health || exit 1 21 interval: 15s 22 timeout: 5s 23 retries: 5 24 postgres: 25 image: postgres:latest 26 container_name: postgres 27 hostname: postgres 28 environment: 29 POSTGRES_USER: metabase 30 POSTGRES_DB: metabaseappdb 31 POSTGRES_PASSWORD: mysecretpassword 32 networks: 33 - metanet1 34networks: 35 metanet1: 36 driver: bridge Yolov modeloak hasierako emaitzak # Yolov modelo gordinak lehenengo pausoko argazkietan nahiko emaitza onak lortzen ditu. Autobusak, kotxeak eta kamioiak estatistikoki bereiztea lortzen ditu.\nMatrikulak # Oinarrizko modeloetan ez dator matrikula identifikaziorako ahalmenik. Horretarako modeloa espezifikoki entrenatu beharra dago. Proiektuan zehar hainbat saiakera desberdin egin ditugu:\n1. Saiakera # Ondorengo web orrialdean adierazitako pausoak jarraituz, hasierako 20 argazkirekin burututako entrenamenduak ez digu emaitza onik eskeini. YOLO modeloen entrenamenduari buruz sakondutakoan, argazki kopurua handiagoa izan behar dela ondorioztatu dugu.\n2. Saiakera # Entrenamendurako prestaketa # Ikusmen konputazionalerako modeloan entrenatu ahal izateko, sarrera datu multzo bat prestatu beharra dago egitura jakin batean. Alde batetik entrenamendurako argazkiak izango ditugu non identifikatu nahi diren etiketak aurre identifikatuta egongo diren eta bounding box delakoekin inguratuta. Ondoren test direktorio bat izango dugu. Egitura bera baina argazki gutxiago egongo dira hemen. Modeloak entrenamendua ikasi duenean, probak egiteko erabiliko du hau.\nEgitura hau sortzeko Label Studio erabiltzea erabaki dugu. Hasieran 398 argazki inportatu ditugu eta banan banan ekuz anotatu.\nLabel Studiok, badauka YOLOVek behar dituen formatuan datuak esportatzeko aukera. Aukera hori baliatuz, irudien direktorio bat eta anotazioen direktorio bat sortzen ditu.\nEntrenamendurako ordea, 3 direktorioko bikotetan (anotazioak eta irudiak) banatu behar dira. Horretarako python programatxo bat erabili dugu.\n# Load exported data txts = glob(DATA_PATH + \u0026#39;/**/*.txt\u0026#39;) images = glob(DATA_PATH + \u0026#39;/**/*.jpg\u0026#39;) + glob(DATA_PATH + \u0026#39;/**/*.png\u0026#39;) # Create DataFrame df = pd.DataFrame({\u0026#39;txt\u0026#39;: txts, \u0026#39;image\u0026#39;: images}) # Shuffle and split data df = df.sample(frac=1, random_state=42).reset_index(drop=True) train_size = int(0.8 * len(df)) train_df = df.iloc[:train_size] test_df = df.iloc[train_size:] val_df = test_df.sample(frac=0.5) test_df = test_df.drop(val_df.index) # Create directories for split in [\u0026#39;train\u0026#39;, \u0026#39;test\u0026#39;, \u0026#39;val\u0026#39;]: os.makedirs(f\u0026#39;{TRAINING_PATH}/{split}/images\u0026#39;, exist_ok=True) os.makedirs(f\u0026#39;{TRAINING_PATH}/{split}/labels\u0026#39;, exist_ok=True) # Copy files to respective directories for split, split_df in [(\u0026#39;train\u0026#39;, train_df), (\u0026#39;test\u0026#39;, test_df), (\u0026#39;val\u0026#39;, val_df)]: for _, row in split_df.iterrows(): shutil.copy(row[\u0026#39;image\u0026#39;], f\u0026#39;{TRAINING_PATH}/{split}/images\u0026#39;) shutil.copy(row[\u0026#39;txt\u0026#39;], f\u0026#39;{TRAINING_PATH}/{split}/labels\u0026#39;) Behin train, test eta val direktoriotan dena banatuta dagoela data.yaml fitxategia sortu dugu ondorengo edukiarekin:\ntrain: ../train/images val: ../val/images test: ../test/images nc: 1 names: [\u0026#39;matrikula\u0026#39;] {% endhighlight %} Kutxa orientatuak - Oriented Bounding Box (OBB) Model # Matrikulak entrenatzerakoan, irudi asko argertzen diran non matrikula inguratzen duen kutxa optimoa biratuta egongo litzatekeena. Bilaketa burutu ostean Yolov8 OBB entrenatzeko aukera aztertu da. Horretarako programa guztia aldatu behar izan da.\nFrogak burutu ostean, emaitza onak lortu dira eta beraz OBB ereduarekin jarraitzea proposatzen da.\nInoiz ikusitako argazkiekin programa probatu # Estatistikak bildu # "}]